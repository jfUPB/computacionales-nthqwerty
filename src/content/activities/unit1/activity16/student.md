####   Actividad 16

En las próximas unidades quiero profundizar en cómo manipular bits y controlar la ALU para crear rutinas en ensamblador que sean más compactas y rápidas. Estoy especialmente interesado en entender a fondo el mapa de memoria del Hack —incluyendo la memoria de vídeo y cómo funciona el “memory-mapped I/O”—, porque creo que conocer bien cómo cada instrucción accede a RAM y ROM me ayudará a escribir código que aproveche al máximo los 16 bits y las características propias de la arquitectura.

He comprobado que aprender haciendo pequeños proyectos en ensamblador y plantearme retos de optimización me funciona muy bien. Por ejemplo, resolver un problema concreto en bajo nivel te obliga a enfrentarte a limitaciones de verdad y a pensar en cada ciclo de reloj. Además, repasar de forma espaciada los conceptos clave —con unas flashcards sobre señales de control de la ALU o los formatos de instrucción A y C— me ayuda a no olvidar detalles que luego resultan fundamentales.

Para poner esto en práctica, en cada clase arrancaré con un reto exprés de 10-15 minutos donde tengamos que optimizar un trozo de código en ensamblador o reorganizar datos para mejorar el rendimiento. También dedicaré una sesión semanal de laboratorio a combinar C y ensamblador: escribiré pequeñas funciones en bajo nivel y compararé sus tiempos de ejecución. Todos los descubrimientos y benchmarks los iré anotando en un repositorio compartido, para que el grupo pueda consultarlos y aprender de las mejoras.

Por último, quiero mejorar mi capacidad de depurar código a nivel de hardware usando simuladores del Hack y herramientas de trazado que me permitan identificar cuellos de botella en tiempo real. También me entusiasma la idea de explorar cómo usar intrínsecos SIMD para paralelizar operaciones desde el ensamblador y, en paralelo, familiarizarme con la lectura de datasheets de CPU y GPU reales. Así podré adaptar mis programas a distintas plataformas y sacarles el máximo partido.
